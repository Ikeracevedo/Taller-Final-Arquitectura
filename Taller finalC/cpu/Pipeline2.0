from cache import Cache
from moduloEntradaySalida import Device # Asumiendo que este archivo existe y es correcto
import random

class PipelinedCPU:
    def __init__(self, program):
        self.registers = {
            'R0': 0, 'R1': 0, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0,
            'PC': 0, 'Z': 0
        }
        self.data_memory = [0] * 256
        self.program = program
        
        # Inicializar etapas del pipeline con un NOP que incluya un pc_val inicial
        # Esto ayuda a evitar errores de 'None' type y facilita el seguimiento del PC
        nop_instr_template = {'opcode': 'NOP', 'operands': [], 'pc_val': -1} # PC inicial inválido
        self.IF_stage = {**nop_instr_template}
        self.ID_stage = {**nop_instr_template}
        self.EX_stage = {**nop_instr_template}
        self.MEM_stage = {**nop_instr_template}
        self.WB_stage = {**nop_instr_template}
        
        # Control de Stalls:
        # stall_next_decode: Si es True, la etapa ID del *siguiente* ciclo será un NOP.
        #                    La instrucción en IF se mantiene y PC no avanza.
        self.stall_next_decode = False

        self.cache = Cache(num_lines=16, block_size=8) 
        self.device = Device() 
        self.handling_interrupt = False
        self.saved_PC = None # Para restaurar PC después de una interrupción
        self.stall_count = 0
        self.cycle_count = 0
        self.interrupt_count = 0

    def get_operand_value(self, operand_name_or_value): 
        # Obtiene el valor si el operando es un nombre de registro, o devuelve el valor si es un inmediato.
        if isinstance(operand_name_or_value, str) and operand_name_or_value.startswith('R'):
            return self.registers[operand_name_or_value]
        return operand_name_or_value

    def fetch(self):
        if self.handling_interrupt:
            # Mientras se maneja una interrupción, no se hace fetch de nuevas instrucciones del programa.
            # Se podría inyectar NOPs o instrucciones de la ISR aquí si la ISR se modelara en el pipeline.
            self.IF_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': self.registers['PC']}
            return

        if self.stall_next_decode:
            # Si se indicó un stall para el siguiente decode (que es este ciclo de fetch),
            # no se avanza el PC y no se actualiza IF_stage. IF_stage mantiene la instrucción
            # que causó el stall (o la que estaba en IF cuando se decidió el stall).
            # El flag stall_next_decode será reseteado por decode.
            pass # PC y IF_stage se mantienen congelados.
        else:
            # Fetch normal
            current_pc = self.registers['PC']
            if current_pc < len(self.program):
                # Copiar la instrucción del programa y añadir el PC actual
                self.IF_stage = {**self.program[current_pc], 'pc_val': current_pc}
                self.registers['PC'] = current_pc + 1
            else:
                # No hay más instrucciones, inyectar NOP
                self.IF_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': current_pc}


    def decode(self):
        # Si se indicó un stall para esta etapa de decode en el ciclo anterior:
        if self.stall_next_decode:
            # Insertar NOP en la etapa ID.
            self.ID_stage = {'opcode': 'NOP', 'operands': [], 
                             'pc_val': self.IF_stage.get('pc_val', self.registers['PC'])} # Usar PC de IF si está disponible
            self.stall_count += 1
            # Resetear el flag de stall. La instrucción en IF (que causó el stall)
            # será decodificada de nuevo en el *siguiente* ciclo si el hazard persiste,
            # o procederá si el hazard se resolvió.
            self.stall_next_decode = False 
            return

        # Tomar la instrucción de la etapa IF (resultado del fetch del ciclo anterior)
        instruction_from_IF = self.IF_stage
        if not instruction_from_IF or instruction_from_IF['opcode'] == 'NOP':
            self.ID_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': instruction_from_IF.get('pc_val', self.registers['PC'])}
            return

        opcode = instruction_from_IF['opcode']
        operands = instruction_from_IF['operands']
        pc_val = instruction_from_IF['pc_val'] # PC de esta instrucción

        # Manejo de Saltos (se resuelven en Decode)
        if opcode in ['JMP', 'JZ', 'JNZ', 'JE']:
            take_branch = False
            z_flag = self.registers['Z'] # Asumimos que Z está actualizado por una instrucción previa
            
            # El operando del salto es la dirección (puede ser un inmediato o un registro)
            target_address_operand = operands[0] 
            target_address = self.get_operand_value(target_address_operand)

            if opcode == 'JMP': take_branch = True
            elif opcode == 'JZ' or opcode == 'JE': take_branch = (z_flag == 1)
            elif opcode == 'JNZ': take_branch = (z_flag == 0)
            
            if take_branch:
                self.registers['PC'] = target_address # Actualizar PC para el *próximo* fetch
                # Vaciar IF y convertir ID en NOP para anular la instrucción de salto y la prebuscada.
                self.IF_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': pc_val + 1 if pc_val is not None else self.registers['PC']} # NOP para la instrucción prebuscada incorrectamente
                self.ID_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': pc_val} # La instrucción de salto se convierte en NOP
                # No se necesita stall_next_decode aquí porque el pipeline se purga.
                return 
            else: # No se toma el salto, la instrucción de salto se convierte en NOP
                self.ID_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': pc_val}
                return

        # Decodificación normal y resolución de operandos
        decoded_instruction = {
            'original_instruction': instruction_from_IF, 
            'opcode': opcode,
            'operands': list(operands), 
            'dest_reg': None,
            'src_reg_names': [], # Lista de nombres de registros fuente
            'resolved_src_values': {}, # Diccionario de {nombre_reg_fuente: valor_resuelto}
            'pc_val': pc_val
        }

        # Identificar registros destino y fuente (nombres)
        if opcode in ['ADD', 'SUB', 'MUL', 'AND', 'SHL']: 
            decoded_instruction['dest_reg'] = operands[0]
            if len(operands) > 1: decoded_instruction['src_reg_names'].append(str(operands[1]))
            if len(operands) > 2: decoded_instruction['src_reg_names'].append(str(operands[2]))
        elif opcode == 'LOAD': 
            decoded_instruction['dest_reg'] = operands[0]
            # El segundo operando es la dirección (inmediato o registro)
            if len(operands) > 1 and isinstance(operands[1], str) and operands[1].startswith('R'):
                decoded_instruction['src_reg_names'].append(operands[1]) 
        elif opcode == 'STORE': 
            # El primer operando es el registro fuente a almacenar
            if len(operands) > 0 and isinstance(operands[0], str) and operands[0].startswith('R'):
                decoded_instruction['src_reg_names'].append(operands[0])
            # El segundo operando es la dirección (inmediato o registro)
            if len(operands) > 1 and isinstance(operands[1], str) and operands[1].startswith('R'):
                decoded_instruction['src_reg_names'].append(operands[1])
        elif opcode == 'MOV': 
            decoded_instruction['dest_reg'] = operands[0]
            # El segundo operando es la fuente (inmediato o registro)
            if len(operands) > 1 and isinstance(operands[1], str) and operands[1].startswith('R'):
                decoded_instruction['src_reg_names'].append(operands[1])
        elif opcode == 'CMP': 
             if len(operands) > 0 and isinstance(operands[0], str) and operands[0].startswith('R'): decoded_instruction['src_reg_names'].append(operands[0])
             if len(operands) > 1 and isinstance(operands[1], str) and operands[1].startswith('R'): decoded_instruction['src_reg_names'].append(operands[1])
        
        # Resolver valores de operandos fuente con forwarding
        for reg_name in decoded_instruction['src_reg_names']:
            val = None
            # Prioridad de Forwarding: EX -> MEM -> WB (para datos más recientes)
            # Para ALU ops, el resultado está en EX. Para LOAD, el dato está en MEM.

            # Forwarding desde EX (para resultados de ALU de la instrucción en EX)
            if self.EX_stage and self.EX_stage.get('dest_reg') == reg_name and \
               self.EX_stage['opcode'] not in ['NOP', 'STORE', 'LOAD']: # LOAD data no está listo en EX
                val = self.EX_stage.get('result')
            
            # Forwarding desde MEM (para datos de LOAD de la instrucción en MEM, o ALU ops más antiguas)
            if val is None and self.MEM_stage and self.MEM_stage.get('dest_reg') == reg_name and \
               self.MEM_stage['opcode'] not in ['NOP', 'STORE']:
                val = self.MEM_stage.get('result')
            
            # Forwarding desde WB (para instrucciones aún más antiguas)
            if val is None and self.WB_stage and self.WB_stage.get('dest_reg') == reg_name and \
               self.WB_stage['opcode'] not in ['NOP', 'STORE']:
                val = self.WB_stage.get('result')
            
            # Si no hay forwarding, leer del archivo de registros
            if val is None:
                val = self.registers.get(reg_name) # Usar .get() para evitar KeyError si reg_name es inválido
                if val is None and reg_name.startswith("R"): # Si es un registro esperado pero no encontrado
                    # print(f"Advertencia DECODE: Registro {reg_name} no encontrado, usando 0. PC={pc_val}")
                    val = 0 # Fallback a 0 si el registro no existe (debería existir)
            
            decoded_instruction['resolved_src_values'][reg_name] = val

        # Detección de Hazard de Datos (Load-Use)
        # Si la instrucción actual en ID usa un registro que es destino de un LOAD en EX.
        hazard_detected_this_cycle = False
        if self.EX_stage and self.EX_stage['opcode'] == 'LOAD':
            load_dest_reg = self.EX_stage.get('dest_reg')
            if load_dest_reg and load_dest_reg in decoded_instruction['src_reg_names']:
                # Un LOAD está en EX, y la instrucción actual en ID (instruction_from_IF) usa su resultado.
                # Se necesita un stall. El forwarding desde MEM ocurrirá cuando este LOAD llegue a MEM
                # y la instrucción actual sea decodificada de nuevo.
                hazard_detected_this_cycle = True
        
        if hazard_detected_this_cycle:
            # Indicar que la etapa ID del *siguiente* ciclo debe ser un NOP.
            self.stall_next_decode = True
            # La instrucción actual en IF (que causó el hazard) se mantiene en IF_stage
            # (porque fetch no avanzará debido a stall_next_decode).
            # La etapa ID actual se convierte en NOP.
            self.ID_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': pc_val}
            # No se incrementa stall_count aquí, se hará en el siguiente ciclo cuando el NOP se inserte.
            return

        # Si no hay hazard, la instrucción decodificada pasa a la etapa ID.
        self.ID_stage = decoded_instruction


    def execute(self):
        instruction_in_EX = self.ID_stage # Tomar de la etapa ID del ciclo anterior
        if not instruction_in_EX or instruction_in_EX['opcode'] == 'NOP':
            self.EX_stage = {'opcode': 'NOP', 'operands': [], 'dest_reg': None, 'result': None, 'pc_val': instruction_in_EX.get('pc_val',0)}
            return

        op = instruction_in_EX['opcode']
        operands = instruction_in_EX['operands'] # Nombres/valores originales de los operandos
        resolved_src_values = instruction_in_EX['resolved_src_values'] # Valores ya resueltos por decode
        dest_reg = instruction_in_EX['dest_reg']
        pc_val = instruction_in_EX['pc_val']
        
        result = None # Resultado de la ALU o dirección calculada

        if op in ['ADD', 'SUB', 'MUL', 'AND', 'SHL']:
            # Los operandos fuente ya deberían estar resueltos en resolved_src_values
            # Operands: [dest, src1_name, src2_name]
            src1_name = str(operands[1])
            src2_name = str(operands[2])

            alu_op1 = resolved_src_values.get(src1_name)
            alu_op2 = resolved_src_values.get(src2_name)
            
            # Fallback si por alguna razón no se resolvieron (no debería pasar con decode robusto)
            if alu_op1 is None: alu_op1 = self.get_operand_value(operands[1])
            if alu_op2 is None: alu_op2 = self.get_operand_value(operands[2])

            # Asegurarse que los operandos sean numéricos
            if not isinstance(alu_op1, (int, float)): 
                # print(f"Error EXECUTE: alu_op1 '{alu_op1}' no numérico para {op} {operands} PC={pc_val}. Usando 0.")
                alu_op1 = 0 
            if not isinstance(alu_op2, (int, float)): 
                # print(f"Error EXECUTE: alu_op2 '{alu_op2}' no numérico para {op} {operands} PC={pc_val}. Usando 0.")
                alu_op2 = 0 

            if op == 'ADD': result = alu_op1 + alu_op2
            elif op == 'SUB': result = alu_op1 - alu_op2
            elif op == 'MUL': result = alu_op1 * alu_op2
            elif op == 'AND': result = alu_op1 & alu_op2
            elif op == 'SHL': result = alu_op1 << alu_op2 

            if result is not None:
                self.registers['Z'] = 1 if result == 0 else 0
            
        elif op == 'LOAD':
            # Operands: [dest_reg_name, addr_operand_name_or_imm]
            # El resultado de EX para LOAD es la dirección de memoria calculada.
            addr_operand_spec = operands[1] # Puede ser 'R3' o un número (dirección inmediata)
            if isinstance(addr_operand_spec, str) and addr_operand_spec.startswith('R'):
                # Dirección es el valor del registro base (ej. R3)
                result = resolved_src_values.get(addr_operand_spec)
                if result is None: result = self.get_operand_value(addr_operand_spec) # Fallback
            else: 
                # Dirección es un inmediato
                result = addr_operand_spec 
        
        elif op == 'STORE':
            # Operands: [src_reg_to_store_name, addr_operand_name_or_imm]
            # El resultado de EX para STORE es un dict {'address': ..., 'value': ...}
            src_reg_name = str(operands[0])
            addr_operand_spec = operands[1]
            
            value_to_store = resolved_src_values.get(src_reg_name)
            if value_to_store is None: value_to_store = self.get_operand_value(operands[0]) # Fallback

            calculated_address = None
            if isinstance(addr_operand_spec, str) and addr_operand_spec.startswith('R'):
                calculated_address = resolved_src_values.get(addr_operand_spec)
                if calculated_address is None: calculated_address = self.get_operand_value(addr_operand_spec) # Fallback
            else:
                calculated_address = addr_operand_spec
            
            result = {'address': calculated_address, 'value': value_to_store}
            dest_reg = None # STORE no tiene registro destino en el sentido de ALU ops

        elif op == 'MOV':
            # Operands: [dest_reg_name, src_operand_name_or_imm]
            src_operand_spec = operands[1]
            if isinstance(src_operand_spec, str) and src_operand_spec.startswith('R'):
                result = resolved_src_values.get(src_operand_spec)
                if result is None: result = self.get_operand_value(src_operand_spec) # Fallback
            else: 
                result = src_operand_spec
        
        elif op == 'CMP':
            # Operands: [src1_name, src2_name]
            src1_name = str(operands[0])
            src2_name = str(operands[1])

            cmp_op1 = resolved_src_values.get(src1_name)
            cmp_op2 = resolved_src_values.get(src2_name)

            if cmp_op1 is None: cmp_op1 = self.get_operand_value(operands[0]) # Fallback
            if cmp_op2 is None: cmp_op2 = self.get_operand_value(operands[1]) # Fallback
            
            if not isinstance(cmp_op1, (int, float)): cmp_op1 = 0
            if not isinstance(cmp_op2, (int, float)): cmp_op2 = 0

            self.registers['Z'] = 1 if cmp_op1 == cmp_op2 else 0
            result = None 
            dest_reg = None

        self.EX_stage = {
            'original_instruction': instruction_in_EX.get('original_instruction'), 
            'opcode': op,
            'dest_reg': dest_reg,
            'result': result, # Para ALU: resultado; Para LOAD: dirección; Para STORE: {'addr','val'}
            'pc_val': pc_val
        }

    def memory_access(self):
        instruction_in_MEM = self.EX_stage # Tomar de la etapa EX del ciclo anterior
        if not instruction_in_MEM or instruction_in_MEM['opcode'] == 'NOP':
            self.MEM_stage = {'opcode': 'NOP', 'dest_reg': None, 'result': None, 'pc_val': instruction_in_MEM.get('pc_val',0)}
            return

        op = instruction_in_MEM['opcode']
        # Resultado de EX: para LOAD es la dirección, para ALU es el valor, para STORE es dict.
        ex_stage_result = instruction_in_MEM['result'] 
        dest_reg = instruction_in_MEM['dest_reg']
        pc_val = instruction_in_MEM['pc_val']
        
        # El resultado que se pasará a WB. Para LOAD, será el dato leído. Para otros, el resultado de EX.
        result_for_wb = ex_stage_result 

        if op == 'LOAD':
            address = ex_stage_result # Esto es la dirección calculada en EX
            if isinstance(address, int):
                data_loaded = self.cache.read(address, self.data_memory)
                result_for_wb = data_loaded # El dato cargado es el resultado para WB
            else:
                # print(f"Error MEMORY: Dirección de LOAD no es entera: {address} para PC={pc_val}")
                result_for_wb = 0 # Valor de error
        
        elif op == 'STORE':
            if isinstance(ex_stage_result, dict):
                address = ex_stage_result.get('address')
                value_to_store = ex_stage_result.get('value')
                if isinstance(address, int) and value_to_store is not None:
                    self.cache.write(address, value_to_store, self.data_memory)
                # else:
                    # print(f"Error MEMORY: Dirección o valor inválido para STORE. Addr: {address}, Val: {value_to_store}, PC={pc_val}")
            result_for_wb = None # STORE no escribe a registro en WB, así que no pasa resultado.

        self.MEM_stage = {
            'original_instruction': instruction_in_MEM.get('original_instruction'),
            'opcode': op,
            'dest_reg': dest_reg,
            'result': result_for_wb, # Este es el valor que irá a WB y será usado para forwarding desde MEM
            'pc_val': pc_val
        }

    def write_back(self):
        instruction_in_WB = self.MEM_stage # Tomar de la etapa MEM del ciclo anterior
        if not instruction_in_WB or instruction_in_WB['opcode'] == 'NOP':
            self.WB_stage = {'opcode': 'NOP', 'dest_reg': None, 'result': None, 'pc_val': instruction_in_WB.get('pc_val',0)}
            return

        op = instruction_in_WB['opcode']
        dest_reg = instruction_in_WB['dest_reg']
        result_to_write = instruction_in_WB['result'] # Resultado de MEM (dato para LOAD, valor para ALU)
        pc_val = instruction_in_WB['pc_val']

        # Escribir en el registro si hay un registro destino y un resultado válido
        # (STORE no tiene dest_reg para escritura aquí, y su result es None desde MEM)
        if dest_reg and result_to_write is not None: 
            self.registers[dest_reg] = result_to_write

        self.WB_stage = {**instruction_in_WB} # Copiar la información de la instrucción que completó WB


    def check_interrupt(self): 
        if self.device.data_ready and not self.handling_interrupt:
            self.handling_interrupt = True # Marcar que se está manejando una interrupción
            self.interrupt_count += 1
            self.saved_PC = self.registers['PC'] # Guardar PC de la siguiente instrucción
            
            # Vaciar etapas tempranas del pipeline para dar paso a la ISR (simulado)
            # En una implementación real, PC se cargaría con la dirección de la ISR.
            # Aquí, simplemente purgamos y la ISR se ejecuta "fuera" del pipeline principal.
            nop_pc = self.registers['PC'] # PC actual para NOPs inyectados
            self.IF_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': nop_pc}
            self.ID_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': nop_pc}
            self.EX_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': nop_pc}
            # MEM y WB continúan procesando instrucciones anteriores a la interrupción.
            return True # Interrupción detectada y se inicia el manejo
        return False

    def interrupt_service_routine_step(self):
        # Simulación de la ejecución de la ISR.
        # print(f"Cycle {self.cycle_count}: Executing ISR...")
        self.registers['R0'] = 999 
        self.registers['PC'] = self.saved_PC # Restaurar PC para continuar el programa interrumpido
        self.handling_interrupt = False # Terminar el manejo de la interrupción
        self.device.clear() # Limpiar la señal de interrupción del dispositivo
        # print(f"Cycle {self.cycle_count}: ISR finished. R0={self.registers['R0']}. PC restored to {self.registers['PC']}")
        # El pipeline se reanudará desde fetch en el siguiente ciclo de step().

    def step(self):
        # Guardar el estado de las etapas *al inicio* del ciclo actual.
        # Estas son las entradas para las etapas lógicas de este ciclo.
        # (En una simulación más estricta, se pasarían explícitamente)
        
        # Ejecutar etapas en orden inverso para simular el flujo de datos correcto
        # La salida de WB_current = func(MEM_previous_cycle_output)
        # La salida de MEM_current = func(EX_previous_cycle_output)
        # etc.

        # Etapa 5: Write Back
        self.write_back() # Usa self.MEM_stage (que es la salida de MEM del ciclo anterior)

        # Etapa 4: Memory Access
        self.memory_access() # Usa self.EX_stage (salida de EX del ciclo anterior)

        # Etapa 3: Execute
        self.execute() # Usa self.ID_stage (salida de ID del ciclo anterior)
        
        # Manejo de Interrupciones (antes de Decode y Fetch del nuevo ciclo)
        if self.handling_interrupt: # Si ya estábamos manejando una interrupción
            self.interrupt_service_routine_step()
            # Después de la ISR, el pipeline (IF,ID,EX) fue purgado.
            # Fetch cargará desde la PC restaurada. Decode y Execute procesarán NOPs este ciclo.
        elif self.check_interrupt(): # Si se detecta una nueva interrupción
            # check_interrupt purga IF,ID,EX. WB,MEM,EX ya se ejecutaron para este ciclo.
            # Decode y Fetch procesarán NOPs o la nueva PC.
            pass # El manejo principal de la interrupción (ISR_step) ocurrirá en el siguiente ciclo.

        # Etapa 2: Decode
        # Si una interrupción acaba de ocurrir y purgar ID, decode procesará un NOP.
        # Si hay un stall indicado por el decode anterior, decode manejará eso.
        self.decode() # Usa self.IF_stage (salida de IF del ciclo anterior)

        # Etapa 1: Fetch
        # Si una interrupción ocurrió, fetch podría estar cargando desde la PC de la ISR o la PC restaurada.
        # Si hubo un stall, fetch podría estar congelado.
        self.fetch()
        
        self.cycle_count += 1


    def run(self, max_cycles=1000):
        self.cycle_count = 0 
        self.stall_count = 0
        self.interrupt_count = 0
        self.cache.hits = 0
        self.cache.misses = 0
        
        self.registers['PC'] = 0 
        nop_instr_template = {'opcode': 'NOP', 'operands': [], 'pc_val': -1}
        self.IF_stage = {**nop_instr_template} # Precargar con NOP
        self.ID_stage = {**nop_instr_template}
        self.EX_stage = {**nop_instr_template}
        self.MEM_stage = {**nop_instr_template}
        self.WB_stage = {**nop_instr_template}
        self.stall_next_decode = False


        # Simular el primer ciclo de fetch para llenar IF_stage antes del bucle principal
        if not self.stall_next_decode: # No debería haber stall al inicio
            current_pc = self.registers['PC']
            if current_pc < len(self.program):
                self.IF_stage = {**self.program[current_pc], 'pc_val': current_pc}
                self.registers['PC'] = current_pc + 1
            else:
                self.IF_stage = {'opcode': 'NOP', 'operands': [], 'pc_val': current_pc}


        while self.cycle_count < max_cycles:
            # Condición de parada: si el pipeline está vacío (solo NOPs) 
            # Y PC ha superado el programa (IF consistentemente trae NOPs)
            # Y no hay interrupciones pendientes.
            
            # Verificar si todas las etapas significativas (ID en adelante) son NOPs
            # y si IF también es NOP porque PC está más allá del programa.
            all_stages_nop_or_done = (
                (self.ID_stage['opcode'] == 'NOP') and
                (self.EX_stage['opcode'] == 'NOP') and
                (self.MEM_stage['opcode'] == 'NOP') and
                (self.WB_stage['opcode'] == 'NOP') and
                (self.IF_stage['opcode'] == 'NOP' and self.registers['PC'] >= len(self.program))
            )

            if all_stages_nop_or_done and not self.device.data_ready and not self.handling_interrupt:
                # print(f"Pipeline vacío y programa terminado en ciclo {self.cycle_count}. Deteniendo.")
                break
            
            # print(f"\n--- Ciclo {self.cycle_count} (PC={self.registers['PC']}) ---") # Descomentar para depuración
            self.step()
            # self.print_pipeline_state() # Descomentar para depuración detallada
            
            if self.cycle_count >= max_cycles : # Usar >= para el último ciclo
                # print(f"Advertencia: Se alcanzó el máximo de {max_cycles} ciclos.")
                break
                
        metrics = {
            'cycles': self.cycle_count,
            'stalls': self.stall_count,
            'cache_hits': self.cache.hits,
            'cache_misses': self.cache.misses,
            'interrupts': self.interrupt_count
        }
        return metrics

    def print_pipeline_state(self): # Para depuración
        def get_op_details(stage_content):
            if stage_content and isinstance(stage_content, dict) and 'opcode' in stage_content:
                op = stage_content['opcode']
                pc = stage_content.get('pc_val', '')
                if op == 'NOP': return f"NOP (PC:{pc})"
                
                # Usar la instrucción original si está disponible para los operandos
                instr_to_display = stage_content.get('original_instruction', stage_content)
                operands_str = ", ".join(map(str, instr_to_display.get('operands', [])))
                
                details = f"{op} {operands_str} (PC:{pc})"
                return details
            return "Empty"

        print(f"IF : [{get_op_details(self.IF_stage)}]")
        print(f"ID : [{get_op_details(self.ID_stage)}]")
        print(f"EX : [{get_op_details(self.EX_stage)}]")
        print(f"MEM: [{get_op_details(self.MEM_stage)}]")
        print(f"WB : [{get_op_details(self.WB_stage)}]")
        print(f"Regs: R0={self.registers['R0']},R1={self.registers['R1']},R2={self.registers['R2']},R3={self.registers['R3']},R4={self.registers['R4']},R5={self.registers['R5']},PC={self.registers['PC']},Z={self.registers['Z']}")
        print(f"Stalls: {self.stall_count}, Interrupts: {self.interrupt_count}, Cache H/M: {self.cache.hits}/{self.cache.misses}")
        if self.stall_next_decode: print(">>>> Stall Signal Active for Next Decode <<<<")
        if self.handling_interrupt: print(">>>> Handling Interrupt <<<<")


def run_benchmarks():
    # BENCHMARK 1
    print("\n=== Benchmark 1: Acceso Secuencial a Memoria ===")
    program_seq = []
    program_seq.append({'opcode': 'MOV', 'operands': ['R1', 1]})   
    program_seq.append({'opcode': 'MOV', 'operands': ['R2', 0]})   
    program_seq.append({'opcode': 'MOV', 'operands': ['R3', 0]})   
    
    for i in range(10): 
        program_seq.append({'opcode': 'LOAD', 'operands': ['R4', 'R3']}) # LOAD R4, [R3]
        program_seq.append({'opcode': 'ADD', 'operands': ['R2', 'R2', 'R4']})
        program_seq.append({'opcode': 'ADD', 'operands': ['R3', 'R3', 'R1']})
    
    cpu_seq = PipelinedCPU(program_seq)
    cpu_seq.data_memory = list(range(100)) # data_memory[i] = i
    
    metrics_seq = cpu_seq.run(max_cycles=100) 
    expected_sum_seq = sum(range(10)) # Suma de 0 a 9 = 45
    print(f"Resultado acumulado R2: {cpu_seq.registers['R2']} (Esperado: {expected_sum_seq})")
    print_metrics(metrics_seq)

    # BENCHMARK 2
    print("\n=== Benchmark 2: Acceso Aleatorio a Memoria ===")
    program_rand = []
    program_rand.append({'opcode': 'MOV', 'operands': ['R2', 0]})  
    
    random.seed(42)  
    random_addresses_b2 = []
    expected_sum_rand = 0
    
    # Llenar memoria para que data_memory[i] = i
    temp_memory_b2_values = list(range(100))

    for _ in range(10):
        addr = random.randint(0, 99)
        random_addresses_b2.append(addr)
        expected_sum_rand += temp_memory_b2_values[addr] # El valor en memoria[addr] es addr
        
        program_rand.append({'opcode': 'LOAD', 'operands': ['R4', addr]}) # LOAD R4, imm_address
        program_rand.append({'opcode': 'ADD', 'operands': ['R2', 'R2', 'R4']})
        
    cpu_rand = PipelinedCPU(program_rand)
    cpu_rand.data_memory = list(range(100)) # data_memory[i] = i
    
    metrics_rand = cpu_rand.run(max_cycles=100)
    print(f"Direcciones aleatorias usadas: {random_addresses_b2}")
    print(f"Resultado acumulado acceso aleatorio R2: {cpu_rand.registers['R2']} (Esperado: {expected_sum_rand})")
    print_metrics(metrics_rand)

    # BENCHMARK 3
    print("\n=== Benchmark 3: Carga y Uso Intensivo de Registros (Hazards) ===")
    program_hazard = [
        {'opcode': 'MOV', 'operands': ['R1', 5]},    
        {'opcode': 'MOV', 'operands': ['R2', 10]},   
        {'opcode': 'ADD', 'operands': ['R3', 'R1', 'R2']},  
        {'opcode': 'SUB', 'operands': ['R4', 'R3', 'R1']},  
        {'opcode': 'MUL', 'operands': ['R5', 'R4', 'R2']}   
    ]
    cpu_hazard = PipelinedCPU(program_hazard)
    metrics_hazard = cpu_hazard.run(max_cycles=50)
    print(f"Resultado R5: {cpu_hazard.registers['R5']} (Esperado: 100)")
    print_metrics(metrics_hazard)

    # BENCHMARK 4
    print("\n=== Benchmark 4: Manejo de Interrupciones ===")
    program_interrupt = [
        {'opcode': 'MOV', 'operands': ['R1', 1]},
        {'opcode': 'MOV', 'operands': ['R2', 2]},
        {'opcode': 'ADD', 'operands': ['R3', 'R1', 'R2']}, # R3 = 3
        {'opcode': 'MOV', 'operands': ['R4', 100]}, 
        {'opcode': 'ADD', 'operands': ['R4', 'R4', 'R1']}, # R4 = 101
        {'opcode': 'ADD', 'operands': ['R4', 'R4', 'R1']}, # R4 = 102
        {'opcode': 'ADD', 'operands': ['R4', 'R4', 'R1']}, # R4 = 103
        {'opcode': 'ADD', 'operands': ['R4', 'R4', 'R1']}, # R4 = 104
    ]
    cpu_interrupt = PipelinedCPU(program_interrupt)
    
    cycles_phase1 = 0
    # Ejecutar algunos ciclos (ej. 7) para que el programa avance antes de la interrupción.
    # El programa tiene 8 instrucciones. Pipeline de 5 etapas.
    # Idealmente, 8 + 5 - 1 = 12 ciclos para completar sin interrupción.
    # Interrumpir alrededor del ciclo 7-10.
    for _ in range(10): 
        # Condición de parada si el pipeline está vacío y el PC ha superado el programa
        is_IF_empty_intr = (cpu_interrupt.IF_stage is None or cpu_interrupt.IF_stage['opcode'] == 'NOP')
        is_ID_empty_intr = (cpu_interrupt.ID_stage is None or cpu_interrupt.ID_stage['opcode'] == 'NOP')
        # ... (comprobaciones similares para EX, MEM, WB)
        pc_beyond_intr = cpu_interrupt.registers['PC'] >= len(program_interrupt) and is_IF_empty_intr
        
        if pc_beyond_intr and is_ID_empty_intr and \
           (cpu_interrupt.EX_stage['opcode'] == 'NOP') and \
           (cpu_interrupt.MEM_stage['opcode'] == 'NOP') and \
           (cpu_interrupt.WB_stage['opcode'] == 'NOP'):
            break
        
        cpu_interrupt.step()
    
    cycles_phase1 = cpu_interrupt.cycle_count
    stalls_phase1 = cpu_interrupt.stall_count
    cache_hits_phase1 = cpu_interrupt.cache.hits
    cache_misses_phase1 = cpu_interrupt.cache.misses
    # interrupt_count se actualiza globalmente, así que no necesitamos guardarlo por separado para sumar.

    cpu_interrupt.device.generate_data(42) # Generar interrupción

    # Continuar ejecución. `run` reseteará sus propios contadores de ciclo/stall/etc.
    # por lo que necesitamos sumar los de la fase 1.
    # El `interrupt_count` de la instancia cpu_interrupt se mantendrá y se incrementará.
    
    # Guardar el estado de las métricas que run() resetea
    run_metrics_phase2 = cpu_interrupt.run(max_cycles=50) 

    final_metrics_interrupt = {
        'cycles': cycles_phase1 + run_metrics_phase2['cycles'], 
        'stalls': stalls_phase1 + run_metrics_phase2['stalls'], 
        'cache_hits': cache_hits_phase1 + run_metrics_phase2['cache_hits'],
        'cache_misses': cache_misses_phase1 + run_metrics_phase2['cache_misses'],
        'interrupts': cpu_interrupt.interrupt_count # Usar el contador final de la instancia
    }

    print(f"Registro R0 (debe ser 999 si se atendió interrupción): {cpu_interrupt.registers['R0']}")
    print(f"Registro R3 (estado final): {cpu_interrupt.registers['R3']}") 
    print(f"Registro R4 (estado final): {cpu_interrupt.registers['R4']}") 
    print_metrics(final_metrics_interrupt)


def print_metrics(metrics):
    print(f"Métricas:")
    print(f"  Ciclos: {metrics['cycles']}")
    print(f"  Stalls: {metrics['stalls']}")
    print(f"  Cache Hits: {metrics['cache_hits']}")
    print(f"  Cache Misses: {metrics['cache_misses']}")
    print(f"  Interrupciones: {metrics['interrupts']}")

if __name__ == "__main__":
    run_benchmarks()
